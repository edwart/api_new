.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "JSON::Validator 3"
.TH JSON::Validator 3 "2017-10-05" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Validator \- Validate data against a JSON schema
.SH "VERSION"
.IX Header "VERSION"
1.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use JSON::Validator;
\&  my $validator = JSON::Validator\->new;
\&
\&  # Define a schema \- http://json\-schema.org/examples.html
\&  # You can also load schema from disk or web
\&  $validator\->schema(
\&    {
\&      type       => "object",
\&      required   => ["firstName", "lastName"],
\&      properties => {
\&        firstName => {type => "string"},
\&        lastName  => {type => "string"},
\&        age       => {type => "integer", minimum => 0, description => "Age in years"}
\&      }
\&    }
\&  );
\&
\&  # Validate your data
\&  @errors = $validator\->validate({firstName => "Jan Henning", lastName => "Thorsen", age => \-42});
\&
\&  # Do something if any errors was found
\&  die "@errors" if @errors;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
JSON::Validator is a class for validating data against \s-1JSON\s0 schemas.
You might want to use this instead of JSON::Schema if you need to
validate data against draft 4 <https://github.com/json-schema/json-schema/tree/master/draft-04>
of the specification.
.PP
This module can be used standalone, but if you want to define a specification
for your webserver's \s-1API,\s0 then have a look at Mojolicious::Plugin::OpenAPI,
which will replace Mojolicious::Plugin::Swagger2.
.SS "Supported schema formats"
.IX Subsection "Supported schema formats"
JSON::Validator can load \s-1JSON\s0 schemas in multiple formats: Plain perl data
structured (as shown in \*(L"\s-1SYNOPSIS\*(R"\s0) or files on disk/web in the \s-1JSON/YAML\s0
format. The \s-1JSON\s0 parsing is done using Mojo::JSON, while the \s-1YAML\s0 parsing
is done with an optional modules which need to be installed manually.
JSON::Validator will look for the \s-1YAML\s0 modules in this order: \s-1YAML::XS\s0,
YAML::Syck. The order is set by which module that performs the best, so it
might change in the future.
.SS "Resources"
.IX Subsection "Resources"
Here are some resources that are related to \s-1JSON\s0 schemas and validation:
.IP "\(bu" 4
<http://json\-schema.org/documentation.html>
.IP "\(bu" 4
<http://spacetelescope.github.io/understanding\-json\-schema/index.html>
.IP "\(bu" 4
<https://github.com/json\-schema/json\-schema/>
.IP "\(bu" 4
Swagger2
.SS "Bundled specifications"
.IX Subsection "Bundled specifications"
This module comes with some \s-1JSON\s0 specifications bundled, so your application
don't have to fetch those from the web. These specifications should be up to
date, but please submit an issue if they are not.
.PP
Files referenced to an \s-1URL\s0 will automatically be cached if the first element in
\&\*(L"cache_paths\*(R" is a writable directory. Note that the cache headers for the
remote assets are \fBnot\fR honored, so you will manually need to remove any
cached file, should you need to refresh them.
.PP
To download and cache an online asset, do this:
.PP
.Vb 1
\&  JSON_VALIDATOR_CACHE_PATH=/some/writable/directory perl myapp.pl
.Ve
.PP
Here is the list of the bundled specifications:
.IP "\(bu" 2
\&\s-1JSON\s0 schema, draft 4
.Sp
Web page: <http://json\-schema.org>
.Sp
\&\f(CW$ref\fR: <http://json\-schema.org/draft\-04/schema#>
.IP "\(bu" 2
\&\s-1JSON\s0 schema for JSONPatch files
.Sp
Web page: <http://jsonpatch.com>
.Sp
\&\f(CW$ref\fR: <http://json.schemastore.org/json\-patch#>
.IP "\(bu" 2
Swagger / OpenAPI specification, version 2
.Sp
Web page: <https://openapis.org>
.Sp
\&\f(CW$ref\fR: <http://swagger.io/v2/schema.json#>
.IP "\(bu" 2
Custom error document
.Sp
There is a custom schema used by Mojolicious::Plugin::OpenAPI as a default
error document. This document might be extended later, but it will always be
backward compatible.
.Sp
Specification: <https://github.com/jhthorsen/json\-validator/blob/master/lib/JSON/Validator/cache/630949337805585c8e52deea27d11419>
.Sp
\&\f(CW$ref\fR: <http://git.io/vcKD4#>.
.IP "\(bu" 2
Swagger Petstore
.Sp
This is used for unit tests, and should probably not be relied on by external
users.
.SH "ERROR OBJECT"
.IX Header "ERROR OBJECT"
.SS "Overview"
.IX Subsection "Overview"
The method \*(L"validate\*(R" and the function \*(L"validate_json\*(R" returns
error objects when the input data violates the \*(L"schema\*(R". Each of
the objects looks like this:
.PP
.Vb 4
\&  bless {
\&    message => "Some description",
\&    path => "/json/path/to/node",
\&  }, "JSON::Validator::Error"
.Ve
.PP
See also JSON::Validator::Error.
.SS "Operators"
.IX Subsection "Operators"
The error object overloads the following operators:
.IP "\(bu" 4
bool
.Sp
Returns a true value.
.IP "\(bu" 4
string
.Sp
Returns the \*(L"path\*(R" and \*(L"message\*(R" part as a string: \*(L"$path: \f(CW$message\fR\*(R".
.SS "Special cases"
.IX Subsection "Special cases"
Have a look at the test suite <https://github.com/jhthorsen/json-validator/tree/master/t>
for documented examples of the error cases. Especially look at \f(CW\*(C`jv\-allof.t\*(C'\fR,
\&\f(CW\*(C`jv\-anyof.t\*(C'\fR and \f(CW\*(C`jv\-oneof.t\*(C'\fR.
.PP
The special cases for \*(L"allOf\*(R", \*(L"anyOf\*(R" and \*(L"oneOf\*(R" will contain the error messages
from all the failing rules below. It can be a bit hard to read, so if the error message
is long, then you might want to run a smaller test with \f(CW\*(C`JSON_VALIDATOR_DEBUG=1\*(C'\fR.
.PP
Example error object:
.PP
.Vb 4
\&  bless {
\&    message => "(String is too long: 8/5. String is too short: 8/12)",
\&    path => "/json/path/to/node",
\&  }, "JSON::Validator::Error"
.Ve
.PP
Note that these error messages are subject for change. Any suggestions are most
welcome!
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "validate_json"
.IX Subsection "validate_json"
.Vb 2
\&  use JSON::Validator "validate_json";
\&  @errors = validate_json $data, $schema;
.Ve
.PP
This can be useful in web applications:
.PP
.Vb 1
\&  @errors = validate_json $c\->req\->json, "data://main/spec.json";
.Ve
.PP
See also \*(L"validate\*(R" and \*(L"\s-1ERROR OBJECT\*(R"\s0 for more details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "cache_paths"
.IX Subsection "cache_paths"
.Vb 2
\&  $self = $self\->cache_paths(\e@paths);
\&  $array_ref = $self\->cache_paths;
.Ve
.PP
A list of directories to where cached specifications are stored. Defaults to
\&\f(CW\*(C`JSON_VALIDATOR_CACHE_PATH\*(C'\fR environment variable and the specs that is bundled
with this distribution.
.PP
\&\f(CW\*(C`JSON_VALIDATOR_CACHE_PATH\*(C'\fR can be a list of directories, each separated by \*(L":\*(R".
.PP
See \*(L"Bundled specifications\*(R" for more details.
.SS "formats"
.IX Subsection "formats"
.Vb 2
\&  $hash_ref = $self\->formats;
\&  $self = $self\->formats(\e%hash);
.Ve
.PP
Holds a hash-ref, where the keys are supported \s-1JSON\s0 type \*(L"formats\*(R", and
the values holds a code block which can validate a given format.
.PP
Note! The modules mentioned below are optional.
.IP "\(bu" 4
date-time
.Sp
An \s-1RFC3339\s0 timestamp in \s-1UTC\s0 time. This is formatted as
\&\*(L"YYYY\-MM\-DDThh:mm:ss.fffZ\*(R". The milliseconds portion (\*(L".fff\*(R") is optional
.IP "\(bu" 4
email
.Sp
Validated against the \s-1RFC5322\s0 spec.
.IP "\(bu" 4
hostname
.Sp
Will be validated using Data::Validate::Domain if installed.
.IP "\(bu" 4
ipv4
.Sp
Will be validated using Data::Validate::IP if installed or
fall back to a plain IPv4 \s-1IP\s0 regex.
.IP "\(bu" 4
ipv6
.Sp
Will be validated using Data::Validate::IP if installed.
.IP "\(bu" 4
regex
.Sp
\&\s-1EXPERIMENTAL.\s0 Will check if the string is a regex, using \f(CW\*(C`qr{...}\*(C'\fR.
.IP "\(bu" 4
uri
.Sp
Validated against the \s-1RFC3986\s0 spec.
.SS "resolver"
.IX Subsection "resolver"
.Vb 2
\&  $code = $self\->resolver;
\&  $self = $self\->resolver(sub { my ($self, $namespace, $refs) = @_; });
.Ve
.PP
Set this to a sub without any logic if you want to skip resolving references,
like this:
.PP
.Vb 1
\&  $self\->resolver(sub {});
.Ve
.PP
This attribute is \s-1EXPERIMENTAL.\s0
.SS "ua"
.IX Subsection "ua"
.Vb 2
\&  $ua = $self\->ua;
\&  $self = $self\->ua(Mojo::UserAgent\->new);
.Ve
.PP
Holds a Mojo::UserAgent object, used by \*(L"schema\*(R" to load a \s-1JSON\s0 schema
from remote location.
.PP
Note that the default Mojo::UserAgent will detect proxy settings and have
\&\*(L"max_redirects\*(R" in Mojo::UserAgent set to 3. (These settings are \s-1EXPERIMENTAL\s0
and might change without a warning)
.SH "METHODS"
.IX Header "METHODS"
.SS "coerce"
.IX Subsection "coerce"
.Vb 4
\&  $self = $self\->coerce(booleans => 1, numbers => 1, strings => 1);
\&  $self = $self\->coerce({booleans => 1, numbers => 1, strings => 1});
\&  $self = $self\->coerce(1) # enable all
\&  $hash = $self\->coerce;
.Ve
.PP
Set the given type to coerce. Before enabling coercion this module is very
strict when it comes to validating types. Example: The string \f(CW"1"\fR is not
the same as the number \f(CW1\fR, unless you have coercion enabled.
.PP
\&\s-1WARNING\s0! Enabling coercion might hide bugs in your api, which would have been
detected if you were strict. For example JavaScript is very picky on a number
being an actual number. This module tries it best to convert the data on the
fly into the proper value, but this means that you unit tests might be ok,
but the client side libraries (that care about types) might break.
.PP
Loading a \s-1YAML\s0 document will enable \*(L"booleans\*(R" automatically. This feature is
experimental, but was added since \s-1YAML\s0 has no real concept of booleans, such
as Mojo::JSON or other \s-1JSON\s0 parsers.
.PP
The coercion rules are \s-1EXPERIMENTAL\s0 and will be tighten/loosen if
bugs are reported. See <https://github.com/jhthorsen/json\-validator/issues/8>
for more details.
.SS "load_and_validate_schema"
.IX Subsection "load_and_validate_schema"
.Vb 1
\&  $self = $self\->load_and_validate_schema($schema, \e%args);
.Ve
.PP
Will load and validate \f(CW$schema\fR against the OpenAPI specification. \f(CW$schema\fR
can be anything \*(L"schema\*(R" in JSON::Validator accepts. The expanded specification
will be stored in \*(L"schema\*(R" in JSON::Validator on success. See
\&\*(L"schema\*(R" in JSON::Validator for the different version of \f(CW$url\fR that can be
accepted.
.PP
\&\f(CW%args\fR can be used to further instruct the validation process:
.IP "\(bu" 2
schema
.Sp
Defaults to \*(L"http://json\-schema.org/draft\-04/schema#\*(R", but can be any
structured that can be used to validate \f(CW$schema\fR.
.SS "schema"
.IX Subsection "schema"
.Vb 4
\&  $self = $self\->schema($json_or_yaml_string);
\&  $self = $self\->schema($url);
\&  $self = $self\->schema(\e%schema);
\&  $schema = $self\->schema;
.Ve
.PP
Used to set a schema from either a data structure or a \s-1URL.\s0
.PP
\&\f(CW$schema\fR will be a Mojo::JSON::Pointer object when loaded,
and \f(CW\*(C`undef\*(C'\fR by default.
.PP
The \f(CW$url\fR can take many forms, but needs to point to a text file in the
\&\s-1JSON\s0 or \s-1YAML\s0 format.
.IP "\(bu" 4
http://... or https://...
.Sp
A web resource will be fetched using the Mojo::UserAgent, stored in \*(L"ua\*(R".
.IP "\(bu" 4
data://Some::Module/file.name
.Sp
This version will use \*(L"data_section\*(R" in Mojo::Loader to load \*(L"file.name\*(R" from
the module \*(L"Some::Module\*(R".
.IP "\(bu" 4
/path/to/file
.Sp
An \s-1URL \s0(without a recognized scheme) will be loaded from disk.
.SS "singleton"
.IX Subsection "singleton"
.Vb 1
\&  $self = $class\->singleton;
.Ve
.PP
Returns the JSON::Validator object used by \*(L"validate_json\*(R".
.SS "validate"
.IX Subsection "validate"
.Vb 2
\&  @errors = $self\->validate($data);
\&  @errors = $self\->validate($data, $schema);
.Ve
.PP
Validates \f(CW$data\fR against a given \s-1JSON \s0\*(L"schema\*(R". \f(CW@errors\fR will
contain validation error objects or be an empty list on success.
.PP
See \*(L"\s-1ERROR OBJECT\*(R"\s0 for details.
.PP
\&\f(CW$schema\fR is optional, but when specified, it will override schema stored in
\&\*(L"schema\*(R". Example:
.PP
.Vb 1
\&  $self\->validate({hero => "superwoman"}, {type => "object"});
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2014\-2015, Jan Henning Thorsen
.PP
This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jan Henning Thorsen \- \f(CW\*(C`jhthorsen@cpan.org\*(C'\fR
.PP
Daniel BÃ¶hmer \- \f(CW\*(C`post@daniel\-boehmer.de\*(C'\fR
.PP
Kevin Goess \- \f(CW\*(C`cpan@goess.org\*(C'\fR
.PP
Martin Renvoize \- \f(CW\*(C`martin.renvoize@gmail.com\*(C'\fR
