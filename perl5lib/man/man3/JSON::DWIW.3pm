.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "JSON::DWIW 3"
.TH JSON::DWIW 3 "2010-09-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::DWIW \- JSON converter that Does What I Want
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use JSON::DWIW;
\& my $json_obj = JSON::DWIW\->new;
\& my $data = $json_obj\->from_json($json_str);
\& my $str = $json_obj\->to_json($data);
\& 
\& my ($data, $error_string) = $json_obj\->from_json($json_str);
\& 
\& my $data = JSON::DWIW::deserialize($json_str);
\& my $error_str = JSON::DWIW::get_error_string();
\& 
\& use JSON::DWIW qw/deserialize_json from_json/
\& my $data = deserialize_json($json_str);
\& my $error_str = JSON::DWIW::get_error_string();
\& 
\& my $error_string = $json_obj\->get_error_string;
\& my $error_data = $json_obj\->get_error_data;
\& my $stats = $json_obj\->get_stats;
\& 
\& my $data = $json_obj\->from_json_file($file)
\& my $ok = $json_obj\->to_json_file($data, $file);
\& 
\& my $data = JSON::DWIW\->from_json($json_str);
\& my $str = JSON::DWIW\->to_json($data);
\& 
\& my $data = JSON::DWIW\->from_json($json_str, \e%options);
\& my $str = JSON::DWIW\->to_json($data, \e%options);
\& 
\& my $true_value = JSON::DWIW\->true;
\& my $false_value = JSON::DWIW\->false;
\& my $data = { var1 => "stuff", var2 => $true_value,
\&              var3 => $false_value, };
\& my $str = JSON::DWIW\->to_json($data);
\&
\& my $data = JSON::DWIW::deserialize($str, { start_depth => 1,
\&                                            start_depth_handler => $handler });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Other \s-1JSON\s0 modules require setting several parameters before
calling the conversion methods to do what I want.  This module
does things by default that I think should be done when working
with \s-1JSON\s0 in Perl.  This module also encodes and decodes faster
than \s-1JSON\s0.pm and JSON::Syck in my benchmarks.
.PP
This means that any piece of data in Perl (assuming it's valid
unicode) will get converted to something in \s-1JSON\s0 instead of
throwing an exception.  It also means that output will be strict
\&\s-1JSON,\s0 while accepted input will be flexible, without having to
set any options.
.PP
For a list of changes in recent versions, see the documentation
for JSON::DWIW::Changes.
.PP
This module can be downloaded from <http://www.cpan.org/authors/id/D/DO/DOWENS/>.
.SS "Encoding"
.IX Subsection "Encoding"
Perl objects get encoded as their underlying data structure, with
the exception of Math::BigInt and Math::BigFloat, which will be
output as numbers, and JSON::DWIW::Boolean, which will get output
as a true or false value (see the \fItrue()\fR and \fIfalse()\fR methods).
For example, a blessed hash ref will be represented as an object
in \s-1JSON,\s0 a blessed array will be represented as an array. etc.  A
reference to a scalar is dereferenced and represented as the
scalar itself.  Globs, Code refs, etc., get stringified, and
undef becomes null.
.PP
Scalars that have been used as both a string and a number will be
output as a string.  A reference to a reference is currently
output as an empty string, but this may change.
.PP
You may notice there is a deserialize function, but not a
serialize one.  The deserialize function was written as a full
rewrite (the parsing is in a separate, event-based library now)
of from_json (now from_json calls deserialize).  In the future,
there will be a serialize function that is a rewrite of to_json.
.SS "Decoding"
.IX Subsection "Decoding"
Input is expected to utf\-8.  When decoding, null, true, and false
become undef, 1, and 0, repectively.  Numbers that appear to be
too long to be supported natively are converted to Math::BigInt
or Math::BigFloat objects, if you have them installed.
Otherwise, long numbers are turned into strings to prevent data
loss.
.PP
The parser is flexible in what it accepts and handles some
things not in the \s-1JSON\s0 spec:
.IP "quotes" 4
.IX Item "quotes"
Both single and double quotes are allowed for quoting a string, e.g.,
.Sp
.Vb 1
\&    [ "string1", \*(Aqstring2\*(Aq ]
.Ve
.IP "bare keys" 4
.IX Item "bare keys"
Object/hash keys can be bare if they look like an identifier, e.g.,
.Sp
.Vb 1
\&    { var1: "myval1", var2: "myval2" }
.Ve
.IP "extra commas" 4
.IX Item "extra commas"
Extra commas in objects/hashes and arrays are ignored, e.g.,
.Sp
.Vb 1
\&    [1,2,3,,,4,]
.Ve
.Sp
becomes a 4 element array containing 1, 2, 3, and 4.
.IP "escape sequences" 4
.IX Item "escape sequences"
Latin1 hexadecimal escape sequences (\exHH) are accepted, as in
Javascript.  Also, the vertical tab escape \ev is recognized (\eu000b).
.IP "comments" 4
.IX Item "comments"
C, \*(C+, and shell-style comments are accepted.  That is
.Sp
.Vb 2
\& /* this is a comment */
\& // this is a comment
\&
\& # this is also a comment
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """new(\e%options)"""
.el .SS "\f(CWnew(\e%options)\fP"
.IX Subsection "new(%options)"
Create a new \s-1JSON::DWIW\s0 object.
.PP
\&\f(CW%options\fR is an optional hash of parameters that will change the
bahavior of this module when encoding to \s-1JSON. \s0 You may also
pass these options as the second argument to \f(CW\*(C`to_json()\*(C'\fR and
\&\f(CW\*(C`from_json()\*(C'\fR.  The following options are supported:
.PP
\fI\fIbare_keys\fI\fR
.IX Subsection "bare_keys"
.PP
If set to a true value, keys in hashes will not be quoted when
converted to \s-1JSON\s0 if they look like identifiers.  This is valid
Javascript in current browsers, but not in \s-1JSON.\s0
.PP
\fI\fIuse_exceptions\fI\fR
.IX Subsection "use_exceptions"
.PP
If set to a true value, errors found when converting to or from
\&\s-1JSON\s0 will result in \f(CW\*(C`die()\*(C'\fR being called with the error message.
The default is to not use exceptions.
.PP
\fI\fIbad_char_policy\fI\fR
.IX Subsection "bad_char_policy"
.PP
This options indicates what should be done if bad characters are
found, e.g., bad utf\-8 sequence.  The default is to return an
error and drop all the output.
.PP
The following values for bad_char_policy are supported:
.PP
\fIerror\fR
.IX Subsection "error"
.PP
default action, i.e., drop any output built up and return an error
.PP
\fIconvert\fR
.IX Subsection "convert"
.PP
Convert to a utf\-8 char using the value of the byte as a code
point.  This is basically the same as assuming the bad character
is in latin\-1 and converting it to utf\-8.
.PP
\fIpass_through\fR
.IX Subsection "pass_through"
.PP
Ignore the error and pass through the raw bytes (invalid \s-1JSON\s0)
.PP
\fI\fIescape_multi_byte\fI\fR
.IX Subsection "escape_multi_byte"
.PP
If set to a true value, escape all multi-byte characters (e.g.,
\&\eu00e9) when converting to \s-1JSON.\s0
.PP
\fI\fIascii\fI\fR
.IX Subsection "ascii"
.PP
Synonym for escape_multi_byte
.PP
\fI\fIpretty\fI\fR
.IX Subsection "pretty"
.PP
Add white space to the output when calling \fIto_json()\fR to make the
output easier for humans to read.
.PP
\fI\fIconvert_bool\fI\fR
.IX Subsection "convert_bool"
.PP
When converting from \s-1JSON,\s0 return objects for booleans so that
\&\*(L"true\*(R" and \*(L"false\*(R" can be maintained when encoding and decoding.
If this flag is set, then \*(L"true\*(R" becomes a JSON::DWIW::Boolean
object that evaluates to true in a boolean context, and \*(L"false\*(R"
becomes an object that evaluates to false in a boolean context.
These objects are recognized by the \fIto_json()\fR method, so they
will be output as \*(L"true\*(R" or \*(L"false\*(R" instead of \*(L"1\*(R" or \*(L"0\*(R".
.PP
\fI\fIbare_solidus\fI\fR
.IX Subsection "bare_solidus"
.PP
Don't escape solidus characters (\*(L"/\*(R") in strings.  The output is
still legal \s-1JSON\s0 with this option turned on.
.PP
\fI\fIminimal_escaping\fI\fR
.IX Subsection "minimal_escaping"
.PP
Only do required escaping in strings (solidus and quote).  Tabs,
newlines, backspaces, etc., will not be escaped with this
optioned turned on (but the output will still be valid \s-1JSON\s0).
.PP
\fI\fIsort_keys\fI\fR
.IX Subsection "sort_keys"
.PP
Set to a true value to sort hash keys (alphabetically) when converting to \s-1JSON.\s0
.PP
\fI\fIparse_number\fI\fR
.IX Subsection "parse_number"
.PP
A subroutine reference to call when parsing a number.  The
subroutine will be provided one string that is the number being
parsed.  The return value from the subroutine will be used to
populate the return data instead of converting to a number.
.PP
E.g.,
.PP
.Vb 2
\&  my $json = \*(Aq{ "a": 6.3e\-10 }\*(Aq;
\&  my $cb = sub { my ($val) = @_; return "I got the number \*(Aq$val\*(Aq"; };
\& 
\&  my $data = JSON::DWIW::deserialize($json, { parse_number => $cb });
.Ve
.PP
\fI\fIparse_constant\fI\fR
.IX Subsection "parse_constant"
.PP
A subroutine reference to call when parsing a constant (true,
false, or null).  The subroutine will be provided one string that
is the constant being parsed.  The return value from the
subroutine will be used to populate the return data instead of
converting to a boolean or undef.  See the \*(L"parse_number\*(R" option.
.PP
\fI\fIstart_depth\fI\fR
.IX Subsection "start_depth"
.PP
Depth at which \f(CW\*(C`start_depth_handler\*(C'\fR should be called.  See \*(L"start_depth_handler\*(R".
.PP
\fI\fIstart_depth_handler\fI\fR
.IX Subsection "start_depth_handler"
.PP
A reference to a subroutine to called when parsing and at level
\&\fIstart_depth\fR in the data structure.  When specified along with \fIstart_depth\fR, the
parser does not return the entire data structure.  Instead, it
calls \fIstart_depth_handler\fR for each element in the array when
the parser is at level \fIstart_depth\fR.  This is useful for
parsing a very large array without loading all the data into
memory (especially when using \f(CW\*(C`deserialize_file\*(C'\fR).
.PP
E.g., with \fIstart_depth\fR set to 1 and \fIstart_depth_handler\fR set to \f(CW$handler\fR:
.PP
.Vb 1
\&    my $str = \*(Aq[ { "foo": "bar", "cat": 1 }, { "concat": 1, "lambda" : [ "one", 2, 3 ] } ]\*(Aq;
\& 
\&    my $foo = { foo => [ ] };
\&    my $handler = sub { push @{$foo\->{foo}}, $_[0]; return 1; };
\& 
\&    my $data = JSON::DWIW::deserialize($str, { start_depth => 1,
\&                                               start_depth_handler => $handler });
\&    print STDERR Data::Dumper\->Dump([ $foo ], [ \*(Aqfoo\*(Aq ]) . "\en";
\&    print STDERR Data::Dumper\->Dump([ $data ], [ \*(Aqleftover_data\*(Aq ]) . "\en";
\&
\&    # Output
\&    $foo = {
\&             \*(Aqfoo\*(Aq => [
\&                        {
\&                          \*(Aqcat\*(Aq => 1,
\&                          \*(Aqfoo\*(Aq => \*(Aqbar\*(Aq
\&                        },
\&                        {
\&                          \*(Aqlambda\*(Aq => [
\&                                      \*(Aqone\*(Aq,
\&                                      2,
\&                                      3
\&                                    ],
\&                          \*(Aqconcat\*(Aq => 1
\&                        }
\&                      ]
\&           };
\&
\&
\&    $leftover_data = [];
.Ve
.ie n .SS """to_json"""
.el .SS "\f(CWto_json\fP"
.IX Subsection "to_json"
Returns the \s-1JSON\s0 representation of \f(CW$data\fR (arbitrary
datastructure).  See http://www.json.org/ for details.
.PP
Called in list context, this method returns a list whose first
element is the encoded \s-1JSON\s0 string and the second element is an
error message, if any.  If \f(CW$error_msg\fR is defined, there was a
problem converting to \s-1JSON. \s0 You may also pass a second argument
to \fIto_json()\fR that is a reference to a hash of options \*(-- see
\&\fInew()\fR.
.PP
.Vb 1
\&     my $json_str = JSON::DWIW\->to_json($data);
\& 
\&     my ($json_str, $error_msg) = JSON::DWIW\->to_json($data);
\& 
\&     my $json_str = JSON::DWIW\->to_json($data, { use_exceptions => 1 });
.Ve
.PP
Aliases: toJson, toJSON, objToJson
.ie n .SS """deserialize($json_str, \e%options)"""
.el .SS "\f(CWdeserialize($json_str, \e%options)\fP"
.IX Subsection "deserialize($json_str, %options)"
Returns the Perl data structure for the given \s-1JSON\s0 string.  The
value for true becomes 1, false becomes 0, and null gets
converted to undef.
.PP
This function should not be called as a method (for performance
reasons).  Unlike \f(CW\*(C`from_json()\*(C'\fR, it returns a single value, the
data structure resulting from the conversion.  If the return
value is undef, check the result of the \f(CW\*(C`get_error_string()\*(C'\fR
function/method to see if an error is defined.
.ie n .SS """deserialize_file($file, \e%options)"""
.el .SS "\f(CWdeserialize_file($file, \e%options)\fP"
.IX Subsection "deserialize_file($file, %options)"
Same as deserialize, except that it takes a file as an argument.
On Unix, this mmap's the file, so it does not load a big file
into memory all at once, and does less buffer copying.
.ie n .SS """from_json"""
.el .SS "\f(CWfrom_json\fP"
.IX Subsection "from_json"
Similar to \f(CW\*(C`deserialize()\*(C'\fR, but expects to be called as a method.
.PP
Called in list context, this method returns a list whose first
element is the data and the second element is the error message,
if any.  If \f(CW$error_msg\fR is defined, there was a problem parsing
the \s-1JSON\s0 string, and \f(CW$data\fR will be undef.  You may also pass a
second argument to \f(CW\*(C`from_json()\*(C'\fR that is a reference to a hash of
options \*(-- see \f(CW\*(C`new()\*(C'\fR.
.PP
.Vb 1
\&     my $data = from_json($json_str)
\& 
\&     my ($data, $error_msg) = from_json($json_str)
.Ve
.PP
Aliases: fromJson, fromJSON, jsonToObj
.ie n .SS """from_json_file"""
.el .SS "\f(CWfrom_json_file\fP"
.IX Subsection "from_json_file"
Similar to \f(CW\*(C`deserialize_file()\*(C'\fR, except that it expects to be
called a a method, and it also returns the error, if any, when called
in list context.
.PP
my ($data, \f(CW$error_msg\fR) = \f(CW$json\fR\->from_json_file($file, \e%options)
.ie n .SS """to_json_file"""
.el .SS "\f(CWto_json_file\fP"
.IX Subsection "to_json_file"
Converts \f(CW$data\fR to \s-1JSON\s0 and writes the result to the file \f(CW$file\fR.
Currently, this is simply a convenience routine that converts
the data to a \s-1JSON\s0 string and then writes it to the file.
.PP
.Vb 1
\& my ($ok, $error) = $json\->to_json_file($data, $file, \e%options);
.Ve
.ie n .SS """get_error_string"""
.el .SS "\f(CWget_error_string\fP"
.IX Subsection "get_error_string"
Returns the error message from the last call, if there was one, e.g.,
.PP
.Vb 2
\& my $data = JSON::DWIW\->from_json($json_str)
\&     or die "JSON error: " . JSON::DWIW\->get_error_string;
\& 
\& my $data = $json_obj\->from_json($json_str)
\&     or die "JSON error: " . $json_obj\->get_error_string;
.Ve
.PP
Aliases: \fIget_err_str()\fR, \fIerrstr()\fR
.ie n .SS """get_error_data"""
.el .SS "\f(CWget_error_data\fP"
.IX Subsection "get_error_data"
Returns the error details from the last call, in a hash ref, e.g.,
.PP
.Vb 8
\& $error_data = {
\&                \*(Aqbyte\*(Aq => 23,
\&                \*(Aqbyte_col\*(Aq => 23,
\&                \*(Aqcol\*(Aq => 22,
\&                \*(Aqchar\*(Aq => 22,
\&                \*(Aqversion\*(Aq => \*(Aq0.15a\*(Aq,
\&                \*(Aqline\*(Aq => 1
\&              };
.Ve
.PP
This is really only useful when decoding \s-1JSON.\s0
.PP
Aliases: \fIget_error()\fR, \fIerror()\fR
.ie n .SS """get_stats"""
.el .SS "\f(CWget_stats\fP"
.IX Subsection "get_stats"
Returns statistics from the last method called to encode or
decode.  E.g., for an encoding (\f(CW\*(C`to_json()\*(C'\fR or \f(CW\*(C`to_json_file()\*(C'\fR),
.PP
.Vb 10
\&    $stats = {
\&               \*(Aqbytes\*(Aq => 78,
\&               \*(Aqnulls\*(Aq => 1,
\&               \*(Aqmax_string_bytes\*(Aq => 5,
\&               \*(Aqmax_depth\*(Aq => 2,
\&               \*(Aqarrays\*(Aq => 1,
\&               \*(Aqnumbers\*(Aq => 6,
\&               \*(Aqlines\*(Aq => 1,
\&               \*(Aqmax_string_chars\*(Aq => 5,
\&               \*(Aqstrings\*(Aq => 6,
\&               \*(Aqbools\*(Aq => 1,
\&               \*(Aqchars\*(Aq => 78,
\&               \*(Aqhashes\*(Aq => 1
\&             };
.Ve
.ie n .SS """true"""
.el .SS "\f(CWtrue\fP"
.IX Subsection "true"
Returns an object that will get output as a true value when encoding to \s-1JSON.\s0
.ie n .SS """false"""
.el .SS "\f(CWfalse\fP"
.IX Subsection "false"
Returns an object that will get output as a false value when encoding to \s-1JSON.\s0
.ie n .SS """json_to_xml($json, \e%params)"""
.el .SS "\f(CWjson_to_xml($json, \e%params)\fP"
.IX Subsection "json_to_xml($json, %params)"
This function (not a method) converts the given \s-1JSON\s0 to \s-1XML.\s0
Hash/object keys become tag names.  Arrays that are hash values
are output as multiple tags with the hash key as the tag name.
.PP
Any characters in hash keys not in \f(CW\*(C`[\ew\-]\*(C'\fR (i.e., letters, numbers,
underscore, or dash), get converted to underscore (\*(L"_\*(R") when
output as \s-1XML\s0 tags.
.PP
Valid parameters in \f(CW\*(C`\e%params\*(C'\fR are the same as for passing
to \f(CW\*(C`deserialize()\*(C'\fR or \f(CW\*(C`from_json()\*(C'\fR, plus the \f(CW\*(C`pretty\*(C'\fR option, which
will add newlines and indentation to the \s-1XML\s0 to make it more
human-readable.
.SH "Utilities"
.IX Header "Utilities"
Following are some methods I use for debugging and testing.
.ie n .SS """flagged_as_utf8($str)"""
.el .SS "\f(CWflagged_as_utf8($str)\fP"
.IX Subsection "flagged_as_utf8($str)"
Returns true if the given string is flagged as utf\-8.
.ie n .SS """flag_as_utf8($str)"""
.el .SS "\f(CWflag_as_utf8($str)\fP"
.IX Subsection "flag_as_utf8($str)"
Flags the given string as utf\-8.
.ie n .SS """unflag_as_utf8($str)"""
.el .SS "\f(CWunflag_as_utf8($str)\fP"
.IX Subsection "unflag_as_utf8($str)"
Clears the flag that tells Perl the string is utf\-8.
.ie n .SS """is_valid_utf8($str)"""
.el .SS "\f(CWis_valid_utf8($str)\fP"
.IX Subsection "is_valid_utf8($str)"
Returns true if the given string is valid utf\-8 (regardless of the flag).
.ie n .SS """upgrade_to_utf8($str)"""
.el .SS "\f(CWupgrade_to_utf8($str)\fP"
.IX Subsection "upgrade_to_utf8($str)"
Converts the string to utf\-8, assuming it is latin1.  This effects \f(CW$str\fR itself in place, but also returns \f(CW$str\fR.
.ie n .SS """code_point_to_utf8_str($cp)"""
.el .SS "\f(CWcode_point_to_utf8_str($cp)\fP"
.IX Subsection "code_point_to_utf8_str($cp)"
Returns a utf8 string containing the byte sequence for the given code point.
.ie n .SS """code_point_to_hex_bytes($cp)"""
.el .SS "\f(CWcode_point_to_hex_bytes($cp)\fP"
.IX Subsection "code_point_to_hex_bytes($cp)"
Returns a string representing the byte sequence for \f(CW$cp\fR encoding in utf\-8.  E.g.,
.PP
.Vb 2
\& my $hex_bytes = JSON::DWIW\->code_point_to_hex_bytes(0xe9);
\& print "$hex_bytes\en"; # \exc3\exa9
.Ve
.ie n .SS """bytes_to_code_points($str)"""
.el .SS "\f(CWbytes_to_code_points($str)\fP"
.IX Subsection "bytes_to_code_points($str)"
Returns a reference to an array of code points from the given string, assuming the string is encoded in utf\-8.
.ie n .SS """peek_scalar($scalar)"""
.el .SS "\f(CWpeek_scalar($scalar)\fP"
.IX Subsection "peek_scalar($scalar)"
Dumps the internal structure of the given scalar.
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Need new benchmarks here.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Perl 5.6 or later
.SH "BUGS/LIMITATIONS"
.IX Header "BUGS/LIMITATIONS"
If you find a bug, please file a tracker request at
<http://rt.cpan.org/Public/Dist/Display.html?Name=JSON\-DWIW>.
.PP
When decoding a \s-1JSON\s0 string, it is a assumed to be utf\-8 encoded.
The module should detect whether the input is utf\-8, utf\-16, or
utf\-32.
.SH "AUTHOR"
.IX Header "AUTHOR"
Don Owens <don@regexguy.com>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Asher Blum for help with testing.
.PP
Thanks to Nigel Bowden for helping with compilation on Windows.
.PP
Thanks to Robert Peters for discovering and tracking down the source of a number parsing bug.
.PP
Thanks to Mark Phillips for helping with a bug under Solaris on Sparc.
.PP
Thanks to Josh for helping debug [rt.cpan.org #47344].
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2007\-2010 Don Owens <don@regexguy.com>.  All rights reserved.
.PP
This is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See perlartistic.
.PP
This program is distributed in the hope that it will be
useful, but \s-1WITHOUT ANY WARRANTY\s0; without even the implied
warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR
PURPOSE.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "The \s-1JSON\s0 home page: <http://json.org/>" 4
.IX Item "The JSON home page: <http://json.org/>"
.PD 0
.IP "The \s-1JSON\s0 spec: <http://www.ietf.org/rfc/rfc4627.txt>" 4
.IX Item "The JSON spec: <http://www.ietf.org/rfc/rfc4627.txt>"
.IP "The JSON-RPC spec: <http://json\-rpc.org/wd/JSON\-RPC\-1\-1\-WD\-20060807.html>" 4
.IX Item "The JSON-RPC spec: <http://json-rpc.org/wd/JSON-RPC-1-1-WD-20060807.html>"
.IP "\s-1JSON\s0" 4
.IX Item "JSON"
.IP "JSON::Syck (included in YAML::Syck)" 4
.IX Item "JSON::Syck (included in YAML::Syck)"
