.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MooseX::DataModel 3"
.TH MooseX::DataModel 3 "2017-05-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MooseX::DataModel \- Create object models from datastructures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package MyModel {
\&    use MooseX::DataModel;
\&
\&    version => (isa => \*(AqInt\*(Aq);
\&    description => (isa => \*(AqStr\*(Aq, required => 1);
\&
\&    sub do_something {
\&      my $self = shift;
\&      if(shift\->version == 3) ... 
\&    }
\&    # Moose is imported for your convenience 
\&    has foo => (...);
\&  }
\&
\&  my $obj = MyModel\->MooseX::DataModel::new_from_json(\*(Aq{"version":3,"description":"a json document"}\*(Aq);
\&  # $obj is just a plain old Moose object
\&  print $obj\->version;
\&
\&  my $obj = MyModel\->new({ version => 6, description => \*(AqA description\*(Aq });
\&  $obj\->do_something;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Working with \*(L"plain datastructures\*(R" (nested hashrefs, arrayrefs and scalars) that come from other 
systems can be a pain.
.PP
Normally those datastructures are not arbitrary: they have some structure to them: most of them 
come to express \*(L"object like\*(R" things. MooseX::DataModel tries to make converting these datastructures
into objects in an easy, declarative fashion.
.PP
Lots of times
.PP
MooseX::DataModel also helps you validate the datastructures. If you get an object back, it conforms
to your object model. So if you declare a required key, and the passed datastructure doesn't contain 
it: you will get an exception. If the type of the key passed is different from the one declared: you
get an exception. The advantage over using a \s-1JSON\s0 validator, is that after validation you still have
your original datastructure. With MooseX::DataModel you get full-blown objects, to which you can
attach logic.
.SH "USAGE"
.IX Header "USAGE"
Just use MooseX::DataModel in a class. It will import three keywords \f(CW\*(C`key\*(C'\fR, \f(CW\*(C`array\*(C'\fR, \f(CW\*(C`object\*(C'\fR.
With these keywords we can specify attributes in our class
.ie n .SS "key attribute => (isa => $type, [required => 1, location => $location])"
.el .SS "key attribute => (isa => \f(CW$type\fP, [required => 1, location => \f(CW$location\fP])"
.IX Subsection "key attribute => (isa => $type, [required => 1, location => $location])"
Declares an attribute named \*(L"attribute\*(R" that is of type \f(CW$type\fR. \f(CW$type\fR can be a string with a
Moose type constraint (Str, Int), or any user defined subtype (MyPositiveInt). Also it can 
be the name of a class. If it's a class, MooseX::DataModel will coerce a HashRef to the 
specified class (using the HashRef as the objects' constructor parameters).
.PP
.Vb 9
\&  package VersionObject {
\&    use MooseX::DataModel;
\&    key major => (isa => \*(AqInt\*(Aq);
\&    key minor => (isa => \*(AqInt\*(Aq);
\&  }
\&  package MyObject {
\&    use MooseX::DataModel;
\&    key version => (isa => \*(AqVersionObject\*(Aq);
\&  }
\&
\&  my $o = MyObject\->MooseX::DataModel::new_from_json(\*(Aq{"version":{"major":3,"minor":5}}\*(Aq);
\&  # $o\->version\->isa(\*(AqVersionObject\*(Aq) == true
\&  print $o\->version\->major;
\&  # prints 3
\&  print $o\->version\->minor;
\&  # prints 5
.Ve
.PP
required => 1: declare that this attribute is obliged to be set in the passed datastructure
.PP
.Vb 6
\&  package MyObject {
\&    use MooseX::DataModel;
\&    key version => (isa => \*(AqInt\*(Aq, required => 1);
\&  }
\&  my $o = MyObject\->MooseX::DataModel::new_from_json(\*(Aq{"document_version":3}\*(Aq);
\&  # exception, since "version" doesn\*(Aqt exist
\&  
\&  my $o = MyObject\->MooseX::DataModel::new_from_json(\*(Aq{"version":3}\*(Aq);
\&  print $o\->version;
\&  # prints 3
.Ve
.PP
location => \f(CW$location:\fR \f(CW$location\fR is a string that specifies in what key of the datastructure to 
find the attributes' value:
.PP
.Vb 7
\&  package MyObject {
\&    use MooseX::DataModel;
\&    key Version => (isa => \*(AqInt\*(Aq, location => \*(Aqdocument_version\*(Aq);
\&  }
\&  my $o = MyObject\->MooseX::DataModel::new_from_json(\*(Aq{"document_version":3}\*(Aq);
\&  print $o\->Version;
\&  # prints 3
.Ve
.ie n .SS "array attribute => (isa => $type, [required => 1, location => $location])"
.el .SS "array attribute => (isa => \f(CW$type\fP, [required => 1, location => \f(CW$location\fP])"
.IX Subsection "array attribute => (isa => $type, [required => 1, location => $location])"
Declares an attribute that holds an array whose elements are of a certain type.
.PP
\&\f(CW$type\fR, required and location work as in \*(L"key\*(R"
.PP
.Vb 8
\&  package MyObject {
\&    use MooseX::DataModel;
\&    key name => (isa => \*(AqStr\*(Aq, required => 1);
\&    array likes => (isa => \*(AqStr\*(Aq, required => 1, location => \*(Aqhis_tastes\*(Aq);
\&  }
\&  my $o = MyObject\->MooseX::DataModel::new_from_json(\*(Aq{"name":"pplu":"his_tastes":["cars","ice cream"]}");
\&  print $o\->likes\->[0];
\&  # prints \*(Aqcars\*(Aq
.Ve
.ie n .SS "object attribute => (isa => $type, [required => 1, location => $location])"
.el .SS "object attribute => (isa => \f(CW$type\fP, [required => 1, location => \f(CW$location\fP])"
.IX Subsection "object attribute => (isa => $type, [required => 1, location => $location])"
Declares an attribute that holds an hash (\*(L"\s-1JS\s0 object\*(R") whose elements are of a certain type. This
is useful when in the datastructure you have a hash with arbitrary keys (for known keys you would
describe an object with the \*(L"key\*(R" keyword.
.PP
\&\f(CW$type\fR, required and location work as in \*(L"key\*(R"
.PP
.Vb 8
\&  package MyObject {
\&    use MooseX::DataModel;
\&    key name => (isa => \*(AqStr\*(Aq, required => 1);
\&    object likes => (isa => \*(AqInt\*(Aq, required => 1, location => \*(Aqhis_tastes\*(Aq);
\&  }
\&  my $o = MyObject\->MooseX::DataModel::new_from_json(\*(Aq{"name":"pplu":"his_tastes":{"cars":9,"ice cream":6}}");
\&  print $o\->likes\->{ cars };
\&  # prints 9
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Your class gets the default Moose constructor. You can pass it a hashref with the datastructure
.PP
.Vb 1
\&  my $o = MyObject\->new({ name => \*(Aqpplu\*(Aq, his_tastes => { cars => 9, \*(Aqice cream\*(Aq => 6 }});
.Ve
.SS "MooseX::DataModel::from_json"
.IX Subsection "MooseX::DataModel::from_json"
There is a convenience constructor for parsing a \s-1JSON \s0(so you don't have to do it from the outside)
.PP
.Vb 1
\&  my $o = MyObject\->MooseX::DataModel::from_json("JSON STRING");
.Ve
.SH "INNER WORKINGS"
.IX Header "INNER WORKINGS"
All this can be done with plain Moose, using subtypes, coercions and declaring the 
appropiate attributes (that's what really happens on the inside, although it's not guaranteed
to stay that way forever). MooseX::DataModel just wants to help you write less code :)
.SH "BUGS and SOURCE"
.IX Header "BUGS and SOURCE"
The source code is located here: https://github.com/pplu/moosex\-datamodel
.PP
Please report bugs to:
.SH "COPYRIGHT and LICENSE"
.IX Header "COPYRIGHT and LICENSE"
.Vb 1
\&    Copyright (c) 2015 by CAPSiDE
\&
\&    This code is distributed under the Apache 2 License. The full text of the license can be found in the LICENSE file included with this module.
.Ve
